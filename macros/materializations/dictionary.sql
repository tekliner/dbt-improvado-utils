{%- materialization dictionary -%}
    {# 
        Steamlines a dictionary creating process by reducing the amount of boilerplate code.
        Creates a dictionary with a "direct" layout for "dev" or "staging" schemas; otherwise, keeps the settings unchanged.
        This materialization requires "--depends_on:{{ ref('<source_table_name>') }}" clause for the "clickhouse" source.
        Arguments:
            source(dictionary, optional):           The source of the dictionary, e.g. "SOURCE(CLICKHOUSE/POSTGRESQL(...))".
                                                    Defaults to "clickhouse" and doesn't require any additional arguments.
                                                    Input format for "postgresql":
                                                        "source": {"name": "postgresql",
                                                                   "named_collection": "collection_name",
                                                                   "table": "table_name"}.

            primary_key(string, required):          Comma-separated list of columns to use as primary key.
                                                    Input format: 'column1, column2, ...'

            columns_to_include(list, optional):     List of columns to include in the dictionary.
                                                    Defaults to "*". When "*" is used, "columns_to_exclude" can be used.
                                                    Input format: ['column1', 'column2', ...]

            columns_to_exclude(list, optional):     List of columns to exclude from the dictionary.
                                                    Input format: ['column1', 'column2', ...]

            lifetime(string, required):             Comma-separated list of dictionary lifetime parameters.
                                                    Input format: '100, 200'

            layout(string, required):               The layout of the dictionary
    #}


-- base settings -------------------------------------------------------------------------------------------------------
    {%- set re                          = modules.re -%}
    {%- set diu                         = dbt_improvado_utils -%}
    {%- set is_prod_schema              = diu.mcr_is_prod_schema() -%}
    {%- set target_relation_exists,
            target_relation             = get_or_create_relation(none, target.schema, this.identifier, none) -%}
    {%- set backup_relation             = make_backup_relation(target_relation, none, suffix='__dbt_backup') -%}

    -- materialization settings
    {%- set source                      = config.get('source', default='clickhouse') -%}
    {%- set primary_key_config          = config.require('primary_key') -%}
    {%- set columns_to_include          = config.get('columns_to_include', default='*') -%}
    {%- set columns_to_exclude          = config.get('columns_to_exclude', default=[]) -%}
    {%- set lifetime_config             = config.require('lifetime').replace(' ', '').split(',') -%}
    {%- set layout_config               = config.require('layout').upper() -%}
    {%- set dev_schema_layout           = 'DIRECT' -%}

    -- ddl patterns
    {%- set create_clause               = 'CREATE OR REPLACE DICTIONARY ' -%}
    {%- set primary_key_pattern         = 'PRIMARY KEY {}' -%}
    {%- set lifetime_pattern            = 'LIFETIME(MIN {} MAX {})' -%}
    {%- set layout_pattern              = 'LAYOUT({})' -%}

    -- source related settings
    {%- if source == 'clickhouse' -%}
        {%- set connection_string       = mcr_source_clickhouse() -%}

        -- patterns to extract params from the "connection_string" generated by the "mcr_source_clickhouse" macro
        {%- set database_pattern        = re.compile('(?i)(?<=db \')(\w+)(?=\')')-%}
        {%- set table_pattern           = re.compile('(?i)(?<=table \')(\w+)(?=\')')-%}

        -- there should always be a match while the "mcr_source_clickhouse" macro is working properly
        {%- set source_database         = database_pattern.search(connection_string).group(0) -%}
        {%- set source_table            = table_pattern.search(connection_string).group(0) -%}

        {%- set source_relation         = adapter.get_relation(none, source_database, source_table) -%}
        {%- set source_columns          = adapter.get_columns_in_relation(source_relation) -%}

    {%- elif source.name.lower() == 'postgresql' -%}
        {%- set named_collection        = source.named_collection -%}
        {%- set source_table            = source.table -%}

        {%- set connection_string       = 'SOURCE(POSTGRESQL(NAME {} TABLE {}))'.format(named_collection, source_table) -%}
        {%- set source_columns          = get_postgresql_columns(named_collection, source_table) -%}

    {%- else -%}
        {%- do exceptions.raise_compiler_error('Invalid source settings') -%}
    {%- endif -%}


-- logic ---------------------------------------------------------------------------------------------------------------
    -- in order to use "loop.last" and set a comma on the last line correctly "source_columns" is filtered
    {%- set filtered_columns = namespace(value=[]) -%}

    {{- log('Filtering columns', info=true) -}}
    {%- if columns_to_include == '*' and columns_to_exclude -%}
        {%- for column in source_columns -%}
            {%- if column.name not in columns_to_exclude -%}
                {%- do filtered_columns.value.append(column) -%}
            {%- endif -%}
        {%- endfor -%}

    {%- elif columns_to_include != '*' and columns_to_include | length > 0 -%}
        {%- for column in source_columns -%}
            {%- if column.name in columns_to_include -%}
                {%- do filtered_columns.value.append(column) -%}
            {%- endif -%}
        {%- endfor -%}

    {%- endif -%}

    -- filtered columns
    {%- set source_columns = filtered_columns.value -%}

    -- generating the dictionary ddl
    {%- set dictionary_ddl = namespace(value=sql) -%}

    {{- log('Generating the dictionary DDL', info=true) -}}
    {%- for column in source_columns -%}
        {%- if loop.first -%}
            {%- set dictionary_ddl.value = dictionary_ddl.value ~ create_clause ~ backup_relation ~ '\n(' -%}
        {%- endif -%}

        {%- set dictionary_ddl.value = dictionary_ddl.value ~ '\n\t`{}` {}'.format(column.name, column.data_type) -%}

        {%- if not loop.last -%}
            {%- set dictionary_ddl.value = dictionary_ddl.value ~ ',' -%}

        {%- else -%}
            {%- set dictionary_ddl.value = dictionary_ddl.value ~ '\n)\n' ~ primary_key_pattern.format(primary_key_config) -%}
            {%- set dictionary_ddl.value = dictionary_ddl.value ~ '\n' ~ connection_string -%}
        {%- endif -%}

    {%- endfor -%}

    {%- set sql = dictionary_ddl.value -%}

    {%- if is_prod_schema -%}
        {%- set sql = sql ~ '\n' ~ lifetime_pattern.format(*lifetime_config) -%}
        {%- set sql = sql ~ '\n' ~ layout_pattern.format(layout_config) -%}

    {%- else -%}
        {%- set sql = sql ~ '\n' ~ layout_pattern.format(dev_schema_layout) -%}
    {%- endif -%}

    {{- log('Executing generated SQL:\n' ~ sql, info=true) -}}
    {%- do run_query(sql) -%}

    {{- log('Checking if the dictionary is queryable', info=true) -}}
    {%- set query_result = run_query('select 1 from ' ~ backup_relation ~ ' limit 1') -%}

    {%- if query_result is none -%}
        {%- do exceptions.raise_compiler_error('Dictionary is not queryable. Aborting') -%}
    {%- endif -%}

    -- if the target relation exists, exchange the tables; rename otherwise
    {%- if target_relation_exists -%}
        {%- do exchange_tables_atomic(backup_relation, target_relation) -%}

    {%- else -%}
        {%- do adapter.rename_relation(backup_relation, target_relation) -%}
    {%- endif -%}

    -- dropping the backup relation
    {%- do diu.mcr_drop_relation_if_exists(backup_relation) -%}

    {%- call noop_statement('main', 'Done') -%} {%- endcall -%}
    {%- do return ({'relations': [target_relation]}) -%}

{%- endmaterialization -%}


{%- macro get_postgresql_columns(named_collection, source_table) -%}
    {#
        Fetches columns list from a PostgreSQL table
        Arguments:
            named_collection(string):   The name of the collection
            source_table(string):       The name of the table
        Returns:
            A list of columns names and types from a PostgreSQL table
    #}

    {%- set query_pattern = "select * from postgresql({}, table='{}')" -%}

    {%- set source_columns = adapter.get_column_schema_from_query(
                                query_pattern.format(
                                    named_collection,
                                    source_table)) -%}

    {{- return(source_columns) -}}

{%- endmacro -%}
